Recursive = built of sub-problem.

1/ Bottom-up approach: solve small cases first and build solution for 1 case from previous case.
2/ top-down approach: divide the problem into sub problems.

3/ half and half: merge sort and binary search


Recursive algorithm:
-/ space inefficient (each recursive call add new layer to stack). If uses depth of n then use O(n) memory
-> implement iterative

Dynamic programming and memorization = recursive algorithm and find the overlapping subproblems -> cache those results for future calls.
Memorization = top-down dynamic programming
dynamic programming  = bottom up dp
